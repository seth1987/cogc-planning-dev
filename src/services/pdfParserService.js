// Service de parsing et extraction de PDF avec Mistral API
import mappingService from './mappingService';

class PDFParserService {
  constructor() {
    this.mistralApiUrl = 'https://api.mistral.ai/v1/chat/completions';
  }

  /**
   * Convertit un PDF en image haute r√©solution via PDF.js
   * OBLIGATOIRE car Mistral ne peut pas lire les PDF directement
   */
  async pdfToImage(file) {
    try {
      console.log('üîÑ Conversion PDF ‚Üí Image haute r√©solution...');
      
      // V√©rifier que PDF.js est disponible
      const pdfjsLib = window.pdfjsLib;
      if (!pdfjsLib) {
        // Charger PDF.js dynamiquement si n√©cessaire
        await this.loadPDFJS();
      }

      // Convertir le fichier en ArrayBuffer
      const arrayBuffer = await file.arrayBuffer();
      
      // Charger le PDF avec PDF.js
      const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      console.log(`üìÑ PDF charg√©: ${pdf.numPages} page(s)`);
      
      // R√©cup√©rer la premi√®re page
      const page = await pdf.getPage(1);
      
      // Utiliser une √©chelle √©lev√©e pour une meilleure qualit√© OCR
      const scale = 3.0; // Haute r√©solution pour meilleure pr√©cision
      const viewport = page.getViewport({ scale });
      
      // Cr√©er un canvas pour rendre la page
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      
      // Rendre la page PDF sur le canvas
      await page.render({
        canvasContext: context,
        viewport: viewport
      }).promise;
      
      // Convertir en base64 avec qualit√© maximale
      const imageData = canvas.toDataURL('image/png', 1.0);
      
      console.log(`‚úÖ PDF converti en image (${canvas.width}x${canvas.height}px)`);
      return imageData;
      
    } catch (error) {
      console.error('‚ùå Erreur conversion PDF:', error);
      throw new Error('Impossible de convertir le PDF. V√©rifiez que le fichier est valide.');
    }
  }

  /**
   * Charge PDF.js dynamiquement si pas pr√©sent
   */
  async loadPDFJS() {
    return new Promise((resolve, reject) => {
      if (window.pdfjsLib) {
        resolve();
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
      script.onload = () => {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        resolve();
      };
      script.onerror = () => reject(new Error('Impossible de charger PDF.js'));
      document.head.appendChild(script);
    });
  }

  /**
   * Parse le PDF avec Mistral API - Version adapt√©e au format liste SNCF
   */
  async parseWithMistralOCR(file, apiKey) {
    if (!apiKey || apiKey === 'sk-proj-default-key' || apiKey.length < 10) {
      throw new Error('Cl√© API Mistral requise. Configurez REACT_APP_MISTRAL_API_KEY.');
    }

    try {
      // 1. Convertir le PDF en image
      const imageData = await this.pdfToImage(file);
      
      console.log('ü§ñ Envoi √† Mistral pixtral pour extraction OCR...');
      
      // 2. Prompt adapt√© au format LISTE de bulletin SNCF
      const prompt = `Analyse cette image d'un bulletin de commande SNCF et extrais TOUTES les donn√©es.

FORMAT DU DOCUMENT:
- En-t√™te: "COGC PN" suivi du NOM et PR√âNOM de l'agent
- Liste chronologique avec pour chaque entr√©e:
  * Date au format JJ/MM/AAAA
  * Code service (ACR002, CCU005, REO008, CENT001, etc.)
  * Description et horaires
  * Services sp√©ciaux: RP, RPP, NU, DISPO, VISIMED, VMT

EXTRACTION REQUISE:
1. L'AGENT apr√®s "COGC PN"
2. Pour CHAQUE DATE dans le document:
   - Extraire la date (JJ/MM/AAAA)
   - Extraire le CODE principal (ACR002, CCU005, etc.)
   - Si c'est "RP Repos p√©riodique" ‚Üí code "RP"
   - Si c'est "RPP" ‚Üí code "RPP"
   - Si c'est "NU" ou "non utilis√©" ‚Üí code "NU"
   - Si c'est "DISPO" ou "Disponible" ‚Üí code "DISPO"
   - Si c'est "VISIMED" ou "VMT" ‚Üí code "VISIMED"

ATTENTION SERVICES DE NUIT:
- Si un service ACR003 a des horaires 22:00 √† 06:00, c'est une NUIT
- Marque ces services avec le flag "isNuit": true

DATES MULTIPLES:
- Si une m√™me date appara√Æt 2 fois (ex: 21/04/2025 avec NU puis ACR003), extraire LES DEUX

RETOURNE CE JSON EXACT:
{
  "agent": {"nom": "NOM_EN_MAJUSCULES", "prenom": "Prenom"},
  "planning": [
    {"date": "15/04/2025", "code": "ACR002"},
    {"date": "16/04/2025", "code": "CCU005"},
    {"date": "17/04/2025", "code": "CCU005"},
    {"date": "18/04/2025", "code": "REO008"},
    {"date": "19/04/2025", "code": "RPP"},
    {"date": "20/04/2025", "code": "RPP"},
    {"date": "21/04/2025", "code": "NU"},
    {"date": "21/04/2025", "code": "ACR003", "isNuit": true},
    {"date": "22/04/2025", "code": "ACR003", "isNuit": true},
    {"date": "23/04/2025", "code": "ACR003", "isNuit": true},
    {"date": "25/04/2025", "code": "RP"},
    {"date": "26/04/2025", "code": "RP"},
    {"date": "27/04/2025", "code": "CENT001"},
    {"date": "28/04/2025", "code": "CENT001"},
    {"date": "29/04/2025", "code": "DISPO"},
    {"date": "30/04/2025", "code": "VISIMED"}
  ]
}

IMPORTANT: Extraire TOUTES les dates visibles, m√™me si certaines apparaissent plusieurs fois.`;

      // 3. Appel API Mistral avec le mod√®le pixtral-12b-2409 (optimis√© pour OCR)
      const response = await fetch(this.mistralApiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: 'pixtral-12b-2409', // Mod√®le sp√©cialis√© OCR
          messages: [
            {
              role: 'user',
              content: [
                {
                  type: 'text',
                  text: prompt
                },
                {
                  type: 'image_url',
                  image_url: imageData // Image PNG haute r√©solution
                }
              ]
            }
          ],
          temperature: 0, // R√©sultats d√©terministes
          max_tokens: 4000,
          top_p: 0.1 // Encore plus de pr√©cision
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Erreur Mistral:', errorText);
        
        // Si pixtral √©choue, essayer avec mistral-large
        if (response.status === 404 || response.status === 400) {
          console.log('‚ö†Ô∏è Fallback sur mistral-large...');
          return await this.fallbackMistralLarge(imageData, apiKey);
        }
        
        throw new Error(`Erreur API Mistral: ${response.status}`);
      }

      const data = await response.json();
      const ocrContent = data.choices[0].message.content;
      
      console.log('üìÑ R√©ponse Mistral:', ocrContent);
      
      // 4. Extraire et parser le JSON
      const jsonMatch = ocrContent.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        console.warn('‚ö†Ô∏è Pas de JSON trouv√©, parsing manuel...');
        return await this.parseManual(ocrContent);
      }

      try {
        const parsedData = JSON.parse(jsonMatch[0]);
        return await this.formatExtractedData(parsedData);
      } catch (parseError) {
        console.error('‚ùå JSON invalide:', parseError);
        return await this.parseManual(ocrContent);
      }
      
    } catch (err) {
      console.error('‚ùå Erreur globale:', err);
      
      if (err.message?.includes('401')) {
        throw new Error('Cl√© API Mistral invalide');
      } else if (err.message?.includes('429')) {
        throw new Error('Limite API atteinte. R√©essayez dans quelques instants.');
      }
      
      throw err;
    }
  }

  /**
   * Fallback avec mistral-large si pixtral √©choue
   */
  async fallbackMistralLarge(imageData, apiKey) {
    console.log('üîÑ Tentative avec mistral-large...');
    
    const response = await fetch(this.mistralApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'mistral-large-latest',
        messages: [
          {
            role: 'system',
            content: 'Tu es un expert en extraction de donn√©es de bulletins SNCF. Extrais toutes les dates et codes de service.'
          },
          {
            role: 'user',
            content: `Analyse ce bulletin SNCF au format LISTE et retourne un JSON avec:
- agent: {nom, prenom} apr√®s "COGC PN"
- planning: tableau avec pour chaque ligne:
  * date: "JJ/MM/AAAA"
  * code: le code service (ACR002, CCU005, etc.)
  * isNuit: true si horaires 22:00-06:00

Codes sp√©ciaux: RP, RPP, NU, DISPO, VISIMED
Si une date appara√Æt 2 fois, extraire les 2 entr√©es.
Retourne UNIQUEMENT le JSON.`
          }
        ],
        temperature: 0,
        max_tokens: 4000
      })
    });

    if (!response.ok) {
      throw new Error('√âchec du fallback mistral-large');
    }

    const data = await response.json();
    const content = data.choices[0].message.content;
    
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      try {
        const parsed = JSON.parse(jsonMatch[0]);
        return await this.formatExtractedData(parsed);
      } catch (e) {
        // Ignorer et continuer
      }
    }
    
    return await this.parseManual(content);
  }

  /**
   * Formater les donn√©es extraites avec mapping et d√©calage nuit
   */
  async formatExtractedData(data) {
    const result = {
      agent: { 
        nom: (data.agent?.nom || '').toUpperCase(), 
        prenom: data.agent?.prenom || '' 
      },
      planning: []
    };

    console.log('üë§ Agent:', result.agent.nom, result.agent.prenom);

    // Traiter chaque entr√©e du planning
    if (data.planning && Array.isArray(data.planning)) {
      for (const entry of data.planning) {
        if (!entry.date || !entry.code) continue;
        
        // Parser la date au format JJ/MM/AAAA
        let dateStr = entry.date;
        let formattedDate;
        
        // G√©rer diff√©rents formats de date
        if (dateStr.includes('/')) {
          const parts = dateStr.split('/');
          if (parts.length === 3) {
            // Format JJ/MM/AAAA
            const [jour, mois, annee] = parts;
            formattedDate = `${annee}-${mois.padStart(2, '0')}-${jour.padStart(2, '0')}`;
          } else if (parts.length === 2) {
            // Format JJ/MM (prendre l'ann√©e courante)
            const [jour, mois] = parts;
            const annee = new Date().getFullYear();
            formattedDate = `${annee}-${mois.padStart(2, '0')}-${jour.padStart(2, '0')}`;
          }
        } else {
          // Si pas de format reconnu, essayer tel quel
          formattedDate = dateStr;
        }
        
        const code = String(entry.code).trim().toUpperCase();
        const isNuit = entry.isNuit === true;
        
        console.log(`üìÖ Date: ${formattedDate}, Code: ${code}${isNuit ? ' (NUIT)' : ''}`);
        
        // Obtenir le mapping depuis la BDD
        const mapping = await mappingService.getPosteFromCode(code);
        
        if (mapping) {
          let targetDate = formattedDate;
          
          // ‚≠ê IMPORTANT: D√©caler les services de nuit au jour suivant
          // Services ACR003 avec flag isNuit OU service === 'X'
          if (isNuit || mapping.service === 'X') {
            const date = new Date(formattedDate + 'T12:00:00');
            date.setDate(date.getDate() + 1);
            targetDate = date.toISOString().split('T')[0];
            console.log(`  üåô Service nuit ‚Üí d√©cal√© au ${targetDate}`);
          }
          
          result.planning.push({
            date: targetDate,
            service_code: mapping.service,
            poste_code: mapping.poste,
            original_code: code,
            description: mapping.description
          });
          
        } else if (this.isSpecialCode(code)) {
          // Codes sp√©ciaux (cong√©s, repos, etc.)
          result.planning.push({
            date: formattedDate,
            service_code: code,
            poste_code: null,
            original_code: code,
            description: this.getSpecialCodeDescription(code)
          });
          
        } else {
          console.warn(`  ‚ö†Ô∏è Code inconnu: ${code}`);
          // Ajouter quand m√™me avec le code tel quel
          result.planning.push({
            date: formattedDate,
            service_code: code,
            poste_code: null,
            original_code: code,
            description: code
          });
        }
      }
    }

    // Trier par date
    result.planning.sort((a, b) => a.date.localeCompare(b.date));
    
    const stats = {
      total: result.planning.length,
      services: result.planning.filter(e => e.poste_code).length,
      conges: result.planning.filter(e => !e.poste_code).length
    };
    
    console.log(`‚úÖ Extraction termin√©e: ${stats.total} entr√©es (${stats.services} services, ${stats.conges} cong√©s/repos)`);
    
    return result;
  }

  /**
   * Parsing manuel de secours si le JSON √©choue
   */
  async parseManual(text) {
    console.log('üîß Parsing manuel du texte...');
    
    const result = {
      agent: { nom: '', prenom: '' },
      planning: []
    };

    // Chercher l'agent
    const agentMatch = text.match(/COGC\s+PN\s+([A-Z]+)\s+([A-Za-z]+)/i);
    if (agentMatch) {
      result.agent.nom = agentMatch[1].toUpperCase();
      result.agent.prenom = agentMatch[2];
    }

    // Pattern pour extraire les dates au format JJ/MM/AAAA et le code
    const patterns = [
      /(\d{2})\/(\d{2})\/(\d{4})\s+([A-Z0-9]+)/gi,          // 15/04/2025 ACR002
      /(\d{2})\/(\d{2})\/(\d{4})\s+\w+\s+([A-Z0-9]+)/gi,    // 15/04/2025 AIDE ACR002
      /(\d{2})\/(\d{2})\/(\d{4})\s+.*?(RP|RPP|NU|DISPO|VISIMED)/gi, // Codes sp√©ciaux
    ];

    for (const pattern of patterns) {
      const matches = [...text.matchAll(pattern)];
      for (const match of matches) {
        let jour, mois, annee, code;
        
        if (match.length === 5) {
          [, jour, mois, annee, code] = match;
        }
        
        if (jour && mois && annee && code) {
          const date = `${annee}-${mois.padStart(2, '0')}-${jour.padStart(2, '0')}`;
          code = code.toUpperCase();
          
          // V√©rifier si c'est un service de nuit (ACR003 g√©n√©ralement)
          const isNuit = code === 'ACR003' && text.includes('22:00') && text.includes('06:00');
          
          const mapping = await mappingService.getPosteFromCode(code);
          if (mapping) {
            let targetDate = date;
            if (isNuit || mapping.service === 'X') {
              const d = new Date(date + 'T12:00:00');
              d.setDate(d.getDate() + 1);
              targetDate = d.toISOString().split('T')[0];
            }
            
            result.planning.push({
              date: targetDate,
              service_code: mapping.service,
              poste_code: mapping.poste,
              original_code: code,
              description: mapping.description
            });
          } else if (this.isSpecialCode(code)) {
            result.planning.push({
              date: date,
              service_code: code,
              poste_code: null,
              original_code: code,
              description: this.getSpecialCodeDescription(code)
            });
          }
        }
      }
    }

    result.planning.sort((a, b) => a.date.localeCompare(b.date));
    console.log(`‚úÖ Parsing manuel: ${result.planning.length} entr√©es`);
    
    return result;
  }

  /**
   * V√©rifie si un code est valide
   */
  isValidCode(code) {
    // Codes num√©riques (001-010)
    if (/^0(0[1-9]|10)$/.test(code)) return true;
    // Codes avec pr√©fixe
    if (/^(CRC|ACR|CCU|CENT|SOUF|REO|RC|RE|RO|CAC)\d{3}$/i.test(code)) return true;
    // Codes sp√©ciaux
    if (this.isSpecialCode(code)) return true;
    return false;
  }

  /**
   * V√©rifie si c'est un code sp√©cial
   */
  isSpecialCode(code) {
    const specialCodes = ['RH', 'RP', 'RPP', 'CA', 'C', 'D', 'DISPO', 'HAB', 'MA', 'I', 'NU', 'INACTIN', 'VISIMED', 'VMT'];
    return specialCodes.includes(code.toUpperCase());
  }

  /**
   * Description des codes sp√©ciaux
   */
  getSpecialCodeDescription(code) {
    const descriptions = {
      'RH': 'RH',
      'RP': 'Repos p√©riodique',
      'RPP': 'Repos p√©riodique prolong√©',
      'CA': 'Cong√© annuel',
      'C': 'Cong√©',
      'D': 'Disponible',
      'DISPO': 'Disponible',
      'HAB': 'Formation/Habilitation',
      'MA': 'Maladie',
      'I': 'Indisponible',
      'NU': 'Non utilis√©',
      'INACTIN': 'Inactivit√©',
      'VISIMED': 'Visite m√©dicale',
      'VMT': 'Visite m√©dicale'
    };
    
    return descriptions[code] || code;
  }

  /**
   * Validation finale des donn√©es
   */
  validateParsedData(data) {
    const errors = [];
    const warnings = [];

    if (!data.agent?.nom || !data.agent?.prenom) {
      warnings.push('Agent non d√©tect√©');
    }

    if (!data.planning || data.planning.length === 0) {
      errors.push('Aucune donn√©e extraite du planning');
    }

    // V√©rifier les doublons (sauf s'ils sont l√©gitimes comme NU + ACR003 le m√™me jour)
    const dateCodeMap = {};
    data.planning.forEach(entry => {
      const key = `${entry.date}_${entry.service_code}`;
      if (dateCodeMap[key]) {
        // C'est OK si c'est NU + service ou deux services diff√©rents le m√™me jour
        if (entry.service_code !== 'NU' && dateCodeMap[key] !== 'NU') {
          warnings.push(`Possible doublon: ${entry.date} - ${entry.service_code}`);
        }
      }
      dateCodeMap[key] = entry.service_code;
    });

    return { 
      isValid: errors.length === 0, 
      errors, 
      warnings 
    };
  }

  /**
   * M√©thode principale
   */
  async parsePDF(file, apiKey) {
    if (!apiKey || apiKey.length < 20) {
      throw new Error('Cl√© API Mistral requise (REACT_APP_MISTRAL_API_KEY)');
    }
    
    return await this.parseWithMistralOCR(file, apiKey);
  }
}

export default new PDFParserService();